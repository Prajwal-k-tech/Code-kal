# ğŸ”¬ ZeroKlue Technical Deep Dive

> **Everything you need to understand what's happening under the hood.**
> 
> This document explains every technology, every flow, and every cryptographic concept in ZeroKlue so you can confidently explain it when questioned.

---

## Table of Contents

1. [The Big Picture](#the-big-picture)
2. [Technology Stack](#technology-stack)
3. [The Complete Flow](#the-complete-flow)
4. [Zero-Knowledge Proofs Explained](#zero-knowledge-proofs-explained)
5. [The JWT Verification Circuit](#the-jwt-verification-circuit)
6. [Smart Contract Architecture](#smart-contract-architecture)
7. [Frontend Architecture](#frontend-architecture)
8. [Cryptographic Primitives](#cryptographic-primitives)
9. [Security Model](#security-model)
10. [Common Questions & Answers](#common-questions--answers)

---

## The Big Picture

### What Problem Are We Solving?

Students need to prove they're students to get discounts. Current solutions (SheerID, UNiDAYS) require:
- âŒ Sharing email addresses
- âŒ Uploading student IDs  
- âŒ Trusting centralized databases
- âŒ Re-verifying at every merchant

### Our Solution

ZeroKlue uses **zero-knowledge proofs** to let students prove they're from a valid university domain **without revealing which university or their email**.

```
Traditional:  "I'm alice@mit.edu" â†’ merchant stores your email forever
ZeroKlue:     "I can prove I'm from a .edu domain" â†’ merchant learns nothing else
```

### The Core Insight

**Google already verifies student emails.** When you sign into Google with your `@university.edu` account, Google's servers have already confirmed:
1. You own that email address
2. The domain is managed by a legitimate organization (Google Workspace)
3. Your email is verified

Google **signs a JWT (JSON Web Token)** containing this information. We verify that signature **inside a ZK circuit** to prove the JWT is authentic without revealing the email.

---

## Technology Stack

### Layer-by-Layer Breakdown

| Layer | Technology | Version | Purpose |
|-------|------------|---------|---------|
| **ZK Circuit** | Noir | 1.0.0-beta.3 | Privacy-preserving computation |
| **JWT Library** | noir-jwt | 0.4.5 | RSA-SHA256 verification in Noir |
| **Proving Backend** | Barretenberg | bb.js 0.82.2 | Generate/verify SNARK proofs |
| **Proof System** | UltraHonk | - | Efficient on-chain verification |
| **Smart Contracts** | Solidity | 0.8.21 | On-chain state + NFT |
| **Contract Framework** | Foundry | 1.5.1 | Testing + deployment |
| **Frontend** | Next.js | 15 | React app |
| **Wallet** | RainbowKit | 2.x | Wallet connection |
| **Ethereum Lib** | wagmi + viem | 2.x | Contract interaction |
| **OAuth** | Google OAuth 2.0 | - | JWT acquisition |
| **Crypto Utils** | @noble/ed25519, @noble/hashes | 2.x | Ephemeral key generation |

### Why These Choices?

**Noir over Circom/Halo2:**
- More developer-friendly (Rust-like syntax)
- Excellent tooling (nargo, NoirJS)
- Active development, great community
- noir-jwt library already exists

**UltraHonk over Groth16:**
- No trusted setup ceremony needed
- Faster verification on-chain
- Generated by `nargo codegen-verifier`

**Scaffold-ETH 2:**
- Pre-configured Foundry + Next.js + RainbowKit
- Saves 5+ hours of boilerplate
- Battle-tested for hackathons

---

## The Complete Flow

### Visual Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ZEROKLUE VERIFICATION FLOW                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                            â”‚
â”‚  STEP 1: CONNECT WALLET                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚  User    â”‚â”€â”€â”€>â”‚ RainbowKit  â”‚â”€â”€â”€>â”‚   wagmi      â”‚                      â”‚
â”‚  â”‚  clicks  â”‚    â”‚   modal     â”‚    â”‚   connect    â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                            â”‚                               â”‚
â”‚                                            â–¼                               â”‚
â”‚                                     wallet address                         â”‚
â”‚                                                                            â”‚
â”‚  STEP 2: GOOGLE OAUTH                                                      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚  User    â”‚â”€â”€â”€>â”‚  Google     â”‚â”€â”€â”€>â”‚   Browser    â”‚                      â”‚
â”‚  â”‚  clicks  â”‚    â”‚  popup      â”‚    â”‚  receives    â”‚                      â”‚
â”‚  â”‚ "Verify" â”‚    â”‚  @uni.edu   â”‚    â”‚  id_token    â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                            â”‚                               â”‚
â”‚                                            â–¼                               â”‚
â”‚                        JWT: { email, hd, exp, ... } + RSA signature        â”‚
â”‚                                                                            â”‚
â”‚  STEP 3: GENERATE EPHEMERAL KEY                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚  Browser generates ed25519 keypair:              â”‚                     â”‚
â”‚  â”‚  - ephemeral_pubkey  (goes into JWT nonce)       â”‚                     â”‚
â”‚  â”‚  - ephemeral_secret  (never leaves browser)      â”‚                     â”‚
â”‚  â”‚  - expiry timestamp  (prevents replay)           â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                           â”‚                                                â”‚
â”‚                           â–¼                                                â”‚
â”‚  STEP 4: ZK PROOF GENERATION (~30 seconds)                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  NoirJS + Barretenberg WASM                                    â”‚       â”‚
â”‚  â”‚                                                                â”‚       â”‚
â”‚  â”‚  PRIVATE INPUTS (hidden):                                      â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ Full JWT payload (email, name, etc.)                      â”‚       â”‚
â”‚  â”‚  â””â”€â”€ JWT signature from Google                                 â”‚       â”‚
â”‚  â”‚                                                                â”‚       â”‚
â”‚  â”‚  CIRCUIT OPERATIONS:                                           â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ Parse JWT header.payload.signature                        â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ Verify RSA-SHA256 signature against Google's public key   â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ Extract email domain ("hd" claim)                         â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ Verify ephemeral key commitment matches JWT nonce         â”‚       â”‚
â”‚  â”‚  â””â”€â”€ Derive ephemeral_pubkey as public output                  â”‚       â”‚
â”‚  â”‚                                                                â”‚       â”‚
â”‚  â”‚  PUBLIC OUTPUTS (85 total):                                    â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ jwt_pubkey_modulus_limbs[0..17]  (Google's RSA key)       â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ domain.storage[18..81]           (hashed domain)          â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ domain.len[82]                   (domain length)          â”‚       â”‚
â”‚  â”‚  â”œâ”€â”€ ephemeral_pubkey[83]             (unique session key)     â”‚       â”‚
â”‚  â”‚  â””â”€â”€ ephemeral_pubkey_expiry[84]      (prevents replay)        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                           â”‚                                                â”‚
â”‚                           â–¼                                                â”‚
â”‚                   proof (Uint8Array) + publicInputs (bytes32[85])          â”‚
â”‚                                                                            â”‚
â”‚  STEP 5: SUBMIT TO SMART CONTRACT                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  wagmi writeContract("verifyAndMint", proof, publicInputs)       â”‚     â”‚
â”‚  â”‚                           â”‚                                      â”‚     â”‚
â”‚  â”‚                           â–¼                                      â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚     â”‚
â”‚  â”‚  â”‚  ZeroKlue.sol                                            â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Verify publicInputs.length == 85                    â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Extract ephemeralPubkey from publicInputs[83]       â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Check !usedEphemeralKeys[ephemeralPubkey]           â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Call HonkVerifier.verify(proof, publicInputs)       â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”‚       â””â”€â”€ Returns true if proof is valid              â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Store verification with timestamp                   â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â”œâ”€â”€ Mark ephemeralPubkey as used                        â”‚   â”‚     â”‚
â”‚  â”‚  â”‚  â””â”€â”€ Emit StudentVerified event                          â”‚   â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                            â”‚
â”‚  STEP 6: SUCCESS!                                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚  Student now has:                                  â”‚                    â”‚
â”‚  â”‚  â”œâ”€â”€ Soulbound NFT (cannot transfer)               â”‚                    â”‚
â”‚  â”‚  â”œâ”€â”€ verifiedAt timestamp                          â”‚                    â”‚
â”‚  â”‚  â””â”€â”€ Can prove status to any merchant              â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Merchant Verification Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        MERCHANT VERIFICATION FLOW                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  User    â”‚â”€â”€â”€>â”‚  Merchant   â”‚â”€â”€â”€>â”‚  ZeroKlue.isVerified()   â”‚          â”‚
â”‚  â”‚ connects â”‚    â”‚   site      â”‚    â”‚  or isRecentlyVerified() â”‚          â”‚
â”‚  â”‚  wallet  â”‚    â”‚   checks    â”‚    â”‚                          â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                   â”‚                        â”‚
â”‚                                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚                                     â”‚                           â”‚         â”‚
â”‚                                     â–¼                           â–¼         â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚                              â”‚   true   â”‚                â”‚  false   â”‚     â”‚
â”‚                              â”‚ Discount â”‚                â”‚ No deal  â”‚     â”‚
â”‚                              â”‚ applied! â”‚                â”‚          â”‚     â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                            â”‚
â”‚  MERCHANT NEVER SEES:                                                      â”‚
â”‚  â”œâ”€â”€ Your email address                                                    â”‚
â”‚  â”œâ”€â”€ Your university name                                                  â”‚
â”‚  â”œâ”€â”€ Any personal information                                              â”‚
â”‚  â””â”€â”€ Anything except: "this wallet is verified"                            â”‚
â”‚                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Zero-Knowledge Proofs Explained

### What Is a Zero-Knowledge Proof?

A ZK proof lets you prove a statement is true **without revealing why it's true**.

**Analogy: Colorblind Friend**

You have a red ball and a green ball. Your colorblind friend doesn't believe they're different colors. You could:

- âŒ Show them the colors (they can't see the difference)
- âŒ Explain RGB values (too technical)
- âœ… ZK proof: Let them hide the balls behind their back, swap or not swap randomly, show you again. You always know if they swapped. After 20 rounds, the probability you're guessing is 1 in a million.

**You proved the balls are different without revealing which is which.**

### How It Applies to ZeroKlue

**Statement**: "I have a valid Google JWT from a .edu domain"

**Traditional Proof**: Show the JWT â†’ merchant sees your email, name, everything

**ZK Proof**: 
- Generate proof that JWT signature is valid
- Prove "hd" claim contains ".edu" 
- Output: cryptographic proof + domain hash
- Merchant learns: "this is a valid .edu account"
- Merchant does NOT learn: email, name, university, anything else

### The Math (Simplified)

1. **Circuit Compilation**: Noir code â†’ arithmetic circuit (gates)
2. **Witness Generation**: Fill in all private/public values
3. **Proof Generation**: Convert witness to polynomial commitments
4. **Verification**: Check polynomial equations hold (fast, ~300K gas)

The proof is small (~1KB) and verification is fast (~300K gas) regardless of circuit size.

---

## The JWT Verification Circuit

### What's a JWT?

```
eyJhbGciOiJSUzI1NiJ9.eyJlbWFpbCI6ImFsaWNlQHVuaS5lZHUiLCJoZCI6InVuaS5lZHUiLCJleHAiOjE3MDAwMDAwMDB9.signature
â””â”€â”€â”€â”€â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â””â”€ Signature â”€â”˜
```

**Header**: Algorithm info (RS256)
**Payload**: Claims (email, domain, expiry, etc.)
**Signature**: RSA-SHA256 signature by Google's private key

### What the Circuit Verifies

```noir
// Simplified circuit logic (actual code in noir-jwt)

fn main(
    // Private inputs (hidden)
    jwt_payload: [u8; 640],           // The full JWT
    jwt_signature: [u128; 18],        // RSA signature
    
    // Public inputs (revealed)
    jwt_pubkey_modulus: [u128; 18],   // Google's RSA public key
    domain: BoundedVec<u8, 64>,       // The email domain
    ephemeral_pubkey: Field,          // Session key
    ephemeral_expiry: Field,          // Replay protection
) {
    // 1. Parse JWT and extract claims
    let claims = parse_jwt(jwt_payload);
    
    // 2. Verify RSA signature against Google's public key
    assert(verify_rsa_signature(
        sha256(jwt_payload),
        jwt_signature,
        jwt_pubkey_modulus
    ));
    
    // 3. Check domain matches "hd" claim in JWT
    assert(claims.hd == domain);
    
    // 4. Verify ephemeral key commitment
    assert(claims.nonce == hash(ephemeral_pubkey, ephemeral_expiry));
    
    // 5. Check JWT hasn't expired
    assert(claims.exp > current_time());
}
```

### Public Inputs Layout (85 total)

| Index | Field | Description |
|-------|-------|-------------|
| 0-17 | `jwt_pubkey_modulus_limbs` | Google's 2048-bit RSA public key, split into 18 x 120-bit limbs |
| 18-81 | `domain.storage` | 64-byte storage for the verified email domain |
| 82 | `domain.len` | Actual length of domain string |
| 83 | `ephemeral_pubkey` | User's session public key (for sybil resistance) |
| 84 | `ephemeral_pubkey_expiry` | Unix timestamp when ephemeral key expires |

### Why 85 Public Inputs?

RSA-2048 needs ~18 limbs for the modulus. The domain is stored as a fixed-size array. This layout matches what HonkVerifier.sol expects.

---

## Smart Contract Architecture

### Contract Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SMART CONTRACT ARCHITECTURE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  HonkVerifier.sol (~1900 lines, auto-generated)                 â”‚    â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚    â”‚
â”‚  â”‚  â€¢ Generated by: `nargo codegen-verifier`                       â”‚    â”‚
â”‚  â”‚  â€¢ Verification key embedded (from circuit)                     â”‚    â”‚
â”‚  â”‚  â€¢ UltraHonk proof system                                       â”‚    â”‚
â”‚  â”‚  â€¢ ~300K gas per verification                                   â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚  interface IVerifier {                                          â”‚    â”‚
â”‚  â”‚      function verify(                                           â”‚    â”‚
â”‚  â”‚          bytes calldata proof,                                  â”‚    â”‚
â”‚  â”‚          bytes32[] calldata publicInputs                        â”‚    â”‚
â”‚  â”‚      ) external view returns (bool);                            â”‚    â”‚
â”‚  â”‚  }                                                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                              â”‚                                           â”‚
â”‚                              â”‚ calls                                     â”‚
â”‚                              â–¼                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  ZeroKlue.sol (~200 lines)                                      â”‚    â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚  STATE:                                                         â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ mapping(address => StudentVerification) verifications      â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ mapping(bytes32 => bool) usedEphemeralKeys                 â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ IVerifier public immutable verifier                        â”‚    â”‚
â”‚  â”‚  â””â”€â”€ uint256 public totalVerified                               â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚  CORE FUNCTIONS:                                                â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ verifyAndMint(proof, publicInputs)                         â”‚    â”‚
â”‚  â”‚  â”‚   â””â”€â”€ Verify proof + mint soulbound NFT                      â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ isVerified(address) â†’ bool                                 â”‚    â”‚
â”‚  â”‚  â”‚   â””â”€â”€ Check if address has valid verification                â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ isRecentlyVerified(address, maxAge) â†’ bool                 â”‚    â”‚
â”‚  â”‚  â”‚   â””â”€â”€ Check if verified within time window                   â”‚    â”‚
â”‚  â”‚  â””â”€â”€ getVerification(address) â†’ (verifiedAt, ephemeralPubkey)   â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚  SYBIL RESISTANCE:                                              â”‚    â”‚
â”‚  â”‚  â€¢ ephemeral_pubkey is marked as "used" after first mint        â”‚    â”‚
â”‚  â”‚  â€¢ Same ephemeral key cannot mint twice                         â”‚    â”‚
â”‚  â”‚  â€¢ User CAN re-verify with new ephemeral key (privacy rotation) â”‚    â”‚
â”‚  â”‚                                                                 â”‚    â”‚
â”‚  â”‚  NFT-LIKE FEATURES:                                             â”‚    â”‚
â”‚  â”‚  â”œâ”€â”€ balanceOf(address) â†’ returns 1 if verified, 0 otherwise    â”‚    â”‚
â”‚  â”‚  â””â”€â”€ transferFrom() â†’ REVERTS (soulbound, cannot transfer)      â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Merchant API

```solidity
// Simple check: Is this wallet verified?
function isVerified(address student) public view returns (bool)

// Time-bounded check: Verified within the last year?
function isRecentlyVerified(address student, uint256 maxAge) public view returns (bool)

// Full details
function getVerification(address student) public view returns (
    uint256 verifiedAt,      // Timestamp
    bytes32 ephemeralPubkey, // Session key used
    uint256 age              // Seconds since verification
)

// Expiring soon warning
function isExpiringSoon(address student, uint256 expiryAge, uint256 warningWindow) public view returns (bool)
```

### Merchant Integration Example

```solidity
// Spotify-like: Strict 1-year verification
contract SpotifyStudentPlan {
    IZeroKlue public zeroKlue;
    
    function getPrice(address user) public view returns (uint256) {
        if (zeroKlue.isRecentlyVerified(user, 365 days)) {
            return 4.99 ether;  // Student price
        }
        return 9.99 ether;  // Regular price
    }
}

// NFT Airdrop: Just need to have been a student ever
contract StudentNFTDrop {
    IZeroKlue public zeroKlue;
    
    function canClaim(address user) public view returns (bool) {
        return zeroKlue.isVerified(user);  // Any verification works
    }
}
```

---

## Frontend Architecture

### Key Files

```
zeroklue-app/packages/nextjs/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ providers/google-oauth.ts   # Google OAuth flow + JWT extraction
â”‚   â”œâ”€â”€ circuits/jwt.ts             # Proof generation with NoirJS
â”‚   â”œâ”€â”€ ephemeral-key.ts            # ed25519 key generation
â”‚   â”œâ”€â”€ lazy-modules.ts             # Async WASM loading
â”‚   â”œâ”€â”€ types.ts                    # TypeScript interfaces
â”‚   â””â”€â”€ utils.ts                    # Helper functions
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useStudentVerification.ts   # Main React hook
â”œâ”€â”€ public/circuits/
â”‚   â”œâ”€â”€ circuit.json                # Compiled Noir circuit (1.3MB)
â”‚   â””â”€â”€ circuit-vkey.json           # Verification key
```

### Proof Generation Pipeline

```typescript
// lib/circuits/jwt.ts (simplified)

export const JWTCircuitHelper = {
  generateProof: async ({ idToken, jwtPubkey, ephemeralKey, domain }) => {
    // 1. Prepare inputs for circuit
    const jwtInputs = await generateInputs({
      jwt: idToken,
      pubkey: jwtPubkey,
      shaPrecomputeTillKeys: ["email", "email_verified", "nonce"],
      maxSignedDataLength: 1024,
    });

    // 2. Load circuit artifact
    const circuitArtifact = await fetch("/circuits/circuit.json").then(r => r.json());
    
    // 3. Initialize prover
    const backend = new UltraHonkBackend(circuitArtifact.bytecode, { threads: 8 });
    const noir = new Noir(circuitArtifact);
    
    // 4. Generate witness + proof (~30 seconds)
    const { witness } = await noir.execute(inputs);
    const { proof, publicInputs } = await backend.generateProof(witness);
    
    // 5. Format for smart contract
    return {
      proofHex: bytesToHex(proof),
      publicInputs: publicInputs.map(formatAsBytes32),
      ephemeralPubkey: publicInputs[83],
    };
  },
};
```

### Hook Usage

```tsx
import { useStudentVerification } from "~~/hooks/useStudentVerification";

function VerifyButton() {
  const { verify, status, progress, error, reset } = useStudentVerification();

  return (
    <div>
      <button onClick={verify} disabled={status !== 'idle'}>
        {status === 'idle' && 'Verify with Google'}
        {status === 'authenticating' && 'Signing in...'}
        {status === 'generating_proof' && `Generating proof... ${progress}%`}
        {status === 'submitting_tx' && 'Submitting to blockchain...'}
        {status === 'success' && 'âœ… Verified!'}
      </button>
      {error && <p className="text-red-500">{error}</p>}
    </div>
  );
}
```

---

## Cryptographic Primitives

### RSA-SHA256 (JWT Signatures)

**What**: Google signs JWTs using RSA-2048 with SHA-256 hashing
**Why**: Industry standard, well-studied, Google uses it
**In Circuit**: noir-jwt library implements modular exponentiation in Noir

```
signature = (SHA256(header.payload))^d mod n
verify: signature^e mod n == SHA256(header.payload)
```

### Ed25519 (Ephemeral Keys)

**What**: Edwards-curve Digital Signature Algorithm
**Why**: Fast, secure, good JavaScript libraries (@noble/ed25519)
**Use**: Generate ephemeral keypair for session binding

```typescript
import * as ed25519 from '@noble/ed25519';

const privateKey = ed25519.utils.randomPrivateKey();
const publicKey = await ed25519.getPublicKeyAsync(privateKey);
```

### Poseidon Hash

**What**: ZK-friendly hash function
**Why**: Much cheaper than SHA256 inside ZK circuits
**Use**: Deriving commitments, nullifiers

### UltraHonk Proof System

**What**: Modern SNARK proof system from Aztec
**Why**: No trusted setup, fast verification, good for on-chain
**Properties**:
- Proof size: ~1-2KB
- Verification gas: ~300K
- Prover time: 20-40 seconds (in browser)

---

## Security Model

### Trust Assumptions

| Entity | What We Trust | Why It's Safe |
|--------|---------------|---------------|
| **Google** | Signs valid JWTs | Massive infrastructure, reputation at stake |
| **Noir Compiler** | Produces correct circuits | Open source, audited |
| **Barretenberg** | Sound proof system | Aztec's production prover, heavily used |
| **Ethereum** | Immutable state | Decentralized consensus |

### What Can Go Wrong?

| Attack | Mitigation |
|--------|------------|
| Fake JWT | RSA signature verification in circuit |
| Replay attack | Ephemeral key + expiry timestamp |
| Same person, multiple wallets | Same ephemeral key blocked |
| JWT after graduation | Merchants can check `verifiedAt` age |
| Proof forgery | Cryptographic soundness of UltraHonk |

### What We DON'T Protect Against

- Google itself being compromised (trusted third party)
- User sharing their ephemeral key (don't do this)
- User using VPN to bypass Google's location checks (not our problem)

---

## Common Questions & Answers

### "Why not just use SheerID?"

SheerID requires:
1. Sharing your email/student ID
2. Trusting their database
3. Re-verifying at every merchant
4. Centralized point of failure

ZeroKlue:
1. Zero personal data revealed
2. On-chain, decentralized
3. One-time verification
4. Cryptographic guarantees

### "Why not use zkEmail?"

zkEmail verifies email contents in ZK. We considered it, but:
- More complex (DKIM signatures, email parsing)
- StealthNote's JWT approach is more elegant
- Google OAuth is more reliable than email headers

### "How long does proof generation take?"

- First time: ~40 seconds (WASM cold start)
- Subsequent: ~30 seconds
- Depends on device (CPU-bound)

### "Can I verify on mobile?"

Technically yes, but:
- Proof generation is CPU-intensive
- May take 60+ seconds on phones
- Some older phones may crash
- Recommend desktop for best experience

### "What if Google changes their signing keys?"

Google rotates keys but publishes them at a well-known endpoint. The circuit uses the current key, which is included as a public input. If keys change, we'd need to update the circuit artifacts.

### "Is the contract upgradeable?"

No. ZeroKlue.sol is immutable once deployed. The verifier is also immutable. If we need to change the circuit, we'd deploy a new verifier and a new ZeroKlue contract.

### "Can merchants see my university?"

No. The domain is hashed in the public inputs. Merchants only see the hash. They can verify "this is a valid .edu domain" but not which one.

### "What happens if I graduate?"

Your verification stays on-chain forever. But merchants can use `isRecentlyVerified(address, 365 days)` to only accept verifications less than a year old. You can re-verify anytime with a new ephemeral key.

---

## Development Commands Reference

```bash
# Start local blockchain
cd zeroklue-app && yarn chain

# Deploy contracts
yarn deploy

# Run frontend
cd packages/nextjs && yarn dev

# Run contract tests
cd packages/foundry && forge test -vvv

# Check for TypeScript errors
cd packages/nextjs && yarn typecheck
```

---

## Resources

- **[Noir Documentation](https://noir-lang.org/docs)** - Learn Noir
- **[noir-jwt Library](https://github.com/saleel/noir-jwt)** - JWT verification in Noir
- **[StealthNote](https://github.com/nicholashc/stealthnote)** - Our circuit source (MIT licensed)
- **[Scaffold-ETH 2](https://docs.scaffoldeth.io)** - Framework docs
- **[Barretenberg](https://github.com/AztecProtocol/barretenberg)** - Proving backend

---

**Now you know exactly what's happening under the hood! ğŸ”¬**
